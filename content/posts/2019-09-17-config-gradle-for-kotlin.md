---
title: "2019 09 17 Config Gradle for Kotlin Backend Service (1)"
date: 2019-09-17T07:39:17-07:00
---

Let's say we are going to implement some web service using Kotlin. The basic idea is that we need to implement certain logic, and expose that through multiple ways to make it available to other applications. We may use HTTP endpoints, or some messaging technologies like Kafka or RabbitMQ.

The business logic should be the same no matter which integration we choose. So here comes the idea of *Service Activator*, which is one of Enterprise Integration Patterns (EIP). The *service* part is just a pure java logic, or simply method. Both input and output is java object. The logic itself don't need to care about the integration method such as HTTP or message queue. The *activator* part will handle all the different integrations, usually by using some framework like [Spring](https://spring.io/).

By applying this idea, our project structure can be like the following:

```
root-project
|--service
|--activator
```

The model sub-project contains all domain models, which can be shared as a client library. The core sub-project contains all business logic, which should be independent from any integration details. The service sub-project is handling all integrations.

Let's talk about how to use [Gradle](https://gradle.org/) to build such kind of applications. Make sure you are using version 5.6+ to follow this article.

```bash
mkdir root-project
cd root-project
gradle init
```

Then we need to change the *settings.gradle* to include all of our sub-projects.

```groovy
include 'service'
include 'activator'

rootProject.name = '<projectNameHere>'
```

We have to specify the Kotlin version we are using for our project. It can be done by importing a specific version of Kotlin plugin in Gradle build file. But we can also put all versions in to one single file to make our life easier in new version of Gradle. We can create *gradle.properties* file to store all library versions. Let's add the following Kotlin version into that file.

```properties
kotlin_version=1.3.50
```

Then we can use 'kotlin_version' as a variable in our main config file. So our *build.gradle* file should take care of the following things:

1. import Kotlin plugin to use the specific Kotlin version in our project.
2. import Java plugin to support common task like compile, test, and assemble.
3. add kotlin library dependencies and common test dependencies.
4. set JVM target to be Java 8 or 11.

So our *build.gradle* on root project will look like the following.

```groovy
buildscript {
    repositories {
        maven { url "https://plugins.gradle.org/m2/" }
        mavenCentral()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}
allprojects {
    apply plugin: 'java'
}

subprojects {
    apply plugin: 'org.jetbrains.kotlin.jvm'

    repositories {
        mavenLocal()
        mavenCentral()
    }

    dependencies {
        implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
        implementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"

        testImplementation 'org.junit.jupiter:junit-jupiter-api'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    }
    compileKotlin {
        kotlinOptions {
            jvmTarget = "11"
        }
    }
    compileTestKotlin {
        kotlinOptions {
            jvmTarget = "11"
        }
    }
}
```

So the updated project structure should be like:

```
root-project
|--service  <--- all business logic
|--activator  <--- all integration endpoints
|--gradle  <-- gradle wrapper jar and config. generated by gradle init
|--gradlew  <-- gradle wrapper script. generated by gradle init
|--build.gradle  <-- top level build script
|--gradle.properties  <-- all dependency versions
|--setting.gradle  <-- project structure config
```

